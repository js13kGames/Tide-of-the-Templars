<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  
  <style>
    #background {
      position: absolute;
      top: 0;
      left: 0;
      width: 200%;
      height: 100%;
      background-image: url('water.svg');
      background-repeat: repeat-x;
      background-size: cover;
      animation: move-background 10s linear infinite;
    }
    
    #game {
      position: absolute;
      top: 0;
      left: 0;
    }

    #container {
      position: relative;
      width: 600px;
      height: 600px;
      overflow: hidden;
      padding: 0;
      margin: 0;
    }
    
    #lifebar-container {
      position: absolute;
      z-index: 1;
      bottom: 20px;
      right: 20px;
      width: 150px;
      height: 20px;
      border: 2px solid rgb(199, 159, 98);
    }

    #lifebar {
      height: 100%;
      width: 100%;
      background-color: blanchedalmond;
      transition: width 1s ease;
    }

    @keyframes move-background {
      from {
        transform: translateX(0);
      }
      to {
        transform: translateX(-50%);
      }
    }
  </style>
</head>
<body>
  <div id="container"><div id="background"></div><div id="lifebar-container"><div id="lifebar"></div></div></div>
  <canvas id="game" tabindex="1" width="600" height="600"></canvas>
  
  <script src="kontra.min.js"></script>
  
  <script type="text/javascript">
    let remainingLife = 100
    let { canvas, context } = kontra.init();
    let sprites = [];
    let rocks = [];
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    kontra.initKeys();
    function createRock() {
      let rock = kontra.Sprite({
        x: canvas.width,
        y: Math.random() * canvas.height,
        width: 30,     // width and height of the sprite rectangle
        height: 30,
        radius: 6,  // we'll use this later for collision detection
        render() {
          this.context.strokeStyle = 'blue';
          this.context.fillStyle = 'lightblue';
          this.context.beginPath();
          this.context.rect(0, 0, 30, 30);
          this.context.fill();
          this.context.stroke();
        },
        update(){
          this.x -= 2;
          if (this.x < 0) {
            this.x = 600;
            this.y = Math.random() * 600;
            this.collided = false
          }
        }
      });
      rocks.push(rock);
      sprites.push(rock);
    }
    for (let i = 0; i < 4; i++) {
      setTimeout(createRock, i * 1000);
    }
    
    async function crashAnimation() {
      const el = document.getElementsByTagName("body")[0]
      for (let i = 0; i < 3; i++) {
        el.style.filter = 'invert(0.4)'
        await sleep(150)
        el.style.filter = ''
        await sleep(150)
      }
    }

    function changeLife(newLife) {
      remainingLife = newLife > 100 ? 100 : (newLife < 0 ? 0 : newLife)
      const lifebar = document.getElementById("lifebar")
      lifebar.style.width = `${remainingLife}%`
    }
    
    let shipImage = new Image();
    shipImage.src = 'boat.png';
    shipImage.onload = function() {
      let ship = kontra.Sprite({
        x: 100,
        y: canvas.height / 2,
        radius: 6, 
        image: shipImage,
        update() {
          // move the ship up and down
          if (kontra.keyPressed('arrowup')) {
            this.ddy = -1; // move the ship up by setting its vertical acceleration to -2
          } else if (kontra.keyPressed('arrowdown')) {
            this.ddy = 1; // move the ship down by setting its vertical acceleration to 2
          } else {
            this.ddy = 0; // reset the vertical acceleration if neither up nor down key is pressed
          }
          
          // rotate the ship based on the acceleration
          this.rotation = (1/30)*this.dy
          
          // limit the ship's movement to the canvas
          if (this.y < 0) {
            this.y = 0;
            this.dy = 0;
          } else if (this.y + this.height > canvas.height) {
            this.y = canvas.height - this.height;
            this.dy = 0;
          }
          
          // check for collisions with rocks
          rocks.forEach(rock => {
            if (!rock.collided && kontra.collides(this, rock)) {
              console.log('Ship collided with a rock!');
              rock.collided = true
              changeLife(remainingLife - 30)
              crashAnimation()
            }
          });
          
          this.advance();
        }
      });
      sprites.push(ship);
    };
    
    let loop = kontra.GameLoop({
      update() {
        sprites.map(sprite => {
          sprite.update();
        })},
        render() {
          sprites.map(sprite => sprite.render());
        }
      });
      loop.start();   // start the game
      //# sourceURL=userscript.js
    </script>
  </body>
  </html>